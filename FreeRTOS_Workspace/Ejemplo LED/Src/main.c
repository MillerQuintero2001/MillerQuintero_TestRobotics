/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "FreeRTOS.h"
#include "task.h"
#include <stm32f4xx.h>

#include <stdint.h>
#include <stdio.h>

#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PLLDriver.h"

#define STACK_SIZE 200

/* Definición de variables del sistema */
uint32_t SystemCoreClock = 16000000;

/* Periféricos del sistema */
GPIO_Handler_t handlerBlinkyPin = {0};	// LED de estado del Pin A5
GPIO_Handler_t handlerButton = {0};	// LED de estado del Pin A5

TaskHandle_t xHandleTask1 = NULL;
TaskHandle_t xHandleTask2 = NULL;

/* Prototipos de funciones */
void initSystem(void);
void vTask_Blink_Led( void * pvParameters );
void vTaskTwo( void * pvParameters );

int main(void)
{

	initSystem();

	/* Activamos la unidad de punto flotante (FPU) */
	SCB->CPACR    |= (0xF << 20);

	/* Activamos del contador de Ticks */
	DWT->CTRL    |= (1 << 0);

	/* Necesario para el SEGGER*/
	vInitPrioGroupValue();

	/* Primero configuramos */
	SEGGER_SYSVIEW_Conf();
	/* Despues activamos el sistema */
	SEGGER_SYSVIEW_Start();

	BaseType_t xReturned;


    xReturned = xTaskCreate(
    				vTask_Blink_Led,       /* Function that implements the task. */
                    "Task-Blink",          /* Text name for the task. */
                    STACK_SIZE,      /* Stack size in words, not bytes. */
                    "Hola Mundo desde la Tarea-1",    /* Parameter passed into the task. */
                    2, /* Priority at which the task is created. */
                    &xHandleTask1 );      /* Used to pass out the created task's handle. */

    configASSERT(xReturned == pdPASS);

    xReturned = xTaskCreate(
    				vTaskTwo,       /* Function that implements the task. */
                    "Task-2",          /* Text name for the task. */
                    STACK_SIZE,      /* Stack size in words, not bytes. */
                    "Hola Mundo desde la Tarea-2",    /* Parameter passed into the task. */
                    2, /* Priority at which the task is created. */
                    &xHandleTask2 );      /* Used to pass out the created task's handle. */

    configASSERT(xReturned == pdPASS);

    vTaskStartScheduler();

    /* Loop forever */
	while(1){
		/* Si llegamos acá, es que algo falla */

	}
}

/** Función que inicia todo el sistema*/
void initSystem(void){
	configPLL(100);

	/* GPIO y Timer del Blinky Led de Estado PA5 */
	handlerBlinkyPin.pGPIOx								= GPIOA;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinNumber 		= PIN_5;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinSpeed 		= GPIO_OSPEED_FAST;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinOPType 		= GPIO_OTYPE_PUSHPULL;
	// Cargo la configuración
	GPIO_Config(&handlerBlinkyPin);
	// Pongo estado en alto
	GPIO_WritePin(&handlerBlinkyPin, SET);

	/* GPIO y Timer del Blinky Led de Estado PA5 */
	handlerButton.pGPIOx								= GPIOC;
	handlerButton.GPIO_PinConfig.GPIO_PinNumber 		= PIN_13;
	handlerButton.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	// Cargo la configuración
	GPIO_Config(&handlerButton);

}

/** Función que gobierna la tarea 1 */
void vTask_Blink_Led( void * pvParameters )
{
	BaseType_t notify = {0};
	uint8_t change_state = 0;


    while(1)
    {
        /* Task code goes here. */
    	if(notify == pdTRUE){
    		change_state = !change_state;
    	}

    	if(change_state){
    		GPIOxTooglePin(&handlerBlinkyPin);
    	}
    	else{
    		GPIO_WritePin(&handlerBlinkyPin, RESET);
    	}
    	//printf("%s\n", (char*)pvParameters);
    	//taskYIELD();
    	notify = xTaskNotifyWait(0,0,NULL,pdMS_TO_TICKS(250));
    	//vTaskDelay(pdMS_TO_TICKS(250));
    }
}

/** Función que gobierna la tarea 2 */
void vTaskTwo( void * pvParameters )
{

	uint8_t button_state = 0;
	uint8_t prev_button_state = 0;

    while(1)
    {
        /* Task code goes here. */
    	button_state = GPIO_ReadPin(&handlerButton);

    	if(button_state){
    		if(!prev_button_state){
    			// Notificación
    			xTaskNotify(xHandleTask1,0,eNoAction);
    		}
    	}
    	prev_button_state = button_state;
    	vTaskDelay(pdMS_TO_TICKS(10));
//    	printf("%s\n", (char*)pvParameters);
//    	taskYIELD();
    }
}


